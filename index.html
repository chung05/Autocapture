<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>智能名片掃描器-強效版</title>
    <script async src="https://docs.opencv.org/4.9.0/opencv.js"></script>
    <style>
        :root { --primary: #10b981; --bg: #0f172a; --text: #f8fafc; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .header { padding: 12px; text-align: center; background: rgba(30, 41, 59, 0.9); z-index: 10; border-bottom: 1px solid rgba(255,255,255,0.1); }
        h1 { margin: 0; font-size: 0.9rem; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; }
        .scanner-container { position: relative; flex: 1; background: #000; display: flex; justify-content: center; align-items: center; }
        #canvasOutput { width: 100%; height: 100%; object-fit: contain; }
        #video { display: none; }
        .overlay { position: absolute; bottom: 30px; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        .status-badge { background: rgba(0, 0, 0, 0.85); padding: 12px 24px; border-radius: 30px; font-size: 0.9rem; border: 2px solid rgba(255, 255, 255, 0.15); margin-bottom: 10px; transition: all 0.3s; }
        .status-badge.stable { border-color: var(--primary); color: var(--primary); box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); transform: scale(1.05); }
        .progress-bar { width: 200px; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; overflow: hidden; display: none; }
        #progressFill { height: 100%; width: 0%; background: var(--primary); transition: width 0.1s linear; }
        #loadingScreen { position: fixed; inset: 0; background: var(--bg); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        .spinner { width: 40px; height: 40px; border: 4px solid rgba(16,185,129,0.2); border-top: 4px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #resultView { position: fixed; inset: 0; background: var(--bg); z-index: 50; display: none; flex-direction: column; padding: 20px; }
        .result-card { background: #1e293b; padding: 8px; border-radius: 12px; margin-top: 10px; text-align: center; flex: 1; display: flex; align-items: center; justify-content: center; }
        #resultImg { max-width: 100%; max-height: 70vh; border-radius: 4px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .action-btns { display: flex; gap: 12px; margin-top: 20px; padding-bottom: 20px; }
        button { flex: 1; padding: 18px; border-radius: 14px; border: none; font-weight: bold; font-size: 1rem; cursor: pointer; }
        .btn-save { background: var(--primary); color: white; }
        .btn-retry { background: #475569; color: white; }
    </style>
</head>
<body>
    <div id="loadingScreen"><div class="spinner"></div><div>正在優化影像演算法...</div></div>
    <div class="header"><h1>智能名片掃描 (反光與圓角加強版)</h1></div>
    <div class="scanner-container">
        <video id="video" playsinline></video>
        <canvas id="canvasOutput"></canvas>
        <div class="overlay">
            <div id="statusBadge" class="status-badge">將名片移入鏡頭...</div>
            <div id="progressContainer" class="progress-bar"><div id="progressFill"></div></div>
        </div>
    </div>
    <div id="resultView">
        <div class="result-card"><img id="resultImg" src=""></div>
        <div class="action-btns">
            <button class="btn-retry" onclick="restartScan()">重新拍攝</button>
            <button class="btn-save" onclick="downloadResult()">保存到相簿</button>
        </div>
    </div>
    <canvas id="canvasBuffer" style="display:none;"></canvas>

    <script>
        let video, canvasOutput, ctxOutput, canvasBuffer, statusBadge, progressFill, progressContainer;
        let streaming = false, stableCount = 0, lastRect = null, scanActive = true;
        const STABLE_REQ = 18; // 稍微提高採樣頻率

        function init() {
            video = document.getElementById('video');
            canvasOutput = document.getElementById('canvasOutput');
            ctxOutput = canvasOutput.getContext('2d', { alpha: false });
            canvasBuffer = document.getElementById('canvasBuffer');
            statusBadge = document.getElementById('statusBadge');
            progressFill = document.getElementById('progressFill');
            progressContainer = document.getElementById('progressContainer');
            checkCV();
        }

        function checkCV() {
            if (typeof cv !== 'undefined' && cv.Mat) {
                document.getElementById('loadingScreen').style.display = 'none';
                startCamera();
            } else { setTimeout(checkCV, 200); }
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => { video.play(); streaming = true; requestAnimationFrame(processLoop); };
            } catch (err) { alert("相機啟動失敗。"); }
        }

        function processLoop() {
            if (!streaming || !scanActive) return;
            if (canvasOutput.width !== video.videoWidth) {
                canvasOutput.width = video.videoWidth;
                canvasOutput.height = video.videoHeight;
            }
            ctxOutput.drawImage(video, 0, 0, canvasOutput.width, canvasOutput.height);

            let src = cv.imread(canvasOutput);
            let gray = new cv.Mat(), binary = new cv.Mat(), morphed = new cv.Mat();
            
            // 1. 影像增強：灰階化
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            
            // 2. 改進點：使用自適應二值化處理反光
            cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
            
            // 3. 改進點：形態學運算 (閉合運算) 填補圓角處的微小斷裂
            let M_kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5, 5));
            cv.morphologyEx(binary, morphed, cv.MORPH_CLOSE, M_kernel);

            let contours = new cv.MatVector(), hierarchy = new cv.Mat();
            cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            let bestCard = null, maxArea = 0;
            const viewArea = src.rows * src.cols;

            for (let i = 0; i < contours.size(); ++i) {
                let cnt = contours.get(i);
                let area = cv.contourArea(cnt);
                if (area < viewArea * 0.1 || area > viewArea * 0.95) continue;

                // 使用 Convex Hull 穩定形狀
                let hull = new cv.Mat();
                cv.convexHull(cnt, hull, false, true);
                
                let peri = cv.arcLength(hull, true);
                let approx = new cv.Mat();
                cv.approxPolyDP(hull, approx, 0.02 * peri, true);

                // 容許 4~8 邊形（為了相容極圓的圓角）
                if (approx.rows >= 4 && approx.rows <= 8) {
                    let rect = cv.boundingRect(approx);
                    let solidity = area / (rect.width * rect.height);
                    
                    // 檢查矩形程度 (Solidity)
                    if (solidity > 0.65 && area > maxArea) {
                        maxArea = area;
                        if (bestCard) bestCard.delete();
                        bestCard = simplifyToFourPoints(approx);
                    } else { approx.delete(); }
                } else { approx.delete(); }
                hull.delete();
            }

            if (bestCard) {
                renderOverlay(bestCard);
                if (validateStability(bestCard)) {
                    stableCount++;
                    statusBadge.innerText = "對準成功，請保持靜止...";
                    statusBadge.classList.add('stable');
                    progressContainer.style.display = 'block';
                    progressFill.style.width = (stableCount / STABLE_REQ * 100) + '%';
                    if (stableCount >= STABLE_REQ) {
                        captureCard(src, bestCard);
                        cleanup([src, gray, binary, morphed, contours, hierarchy, bestCard, M_kernel]);
                        return;
                    }
                } else {
                    stableCount = 0;
                    statusBadge.innerText = "找到名片，穩定中...";
                    statusBadge.classList.remove('stable');
                }
            } else {
                stableCount = 0;
                statusBadge.innerText = "正在尋找邊緣 (請避開強烈反光)";
                progressContainer.style.display = 'none';
            }

            cleanup([src, gray, binary, morphed, contours, hierarchy, bestCard, M_kernel]);
            if (scanActive) requestAnimationFrame(processLoop);
        }

        // 強制將偵測到的形狀映射到最外圍的四個角落
        function simplifyToFourPoints(approx) {
            let pts = [];
            for (let i = 0; i < approx.rows; i++) {
                pts.push({ x: approx.data32S[i*2], y: approx.data32S[i*2+1] });
            }
            // 排序演算法：找和最小(TL)、和最大(BR)、差最小(TR)、差最大(BL)
            let sums = pts.map(p => p.x + p.y);
            let diffs = pts.map(p => p.y - p.x);
            
            let tl = pts[sums.indexOf(Math.min(...sums))];
            let br = pts[sums.indexOf(Math.max(...sums))];
            let tr = pts[diffs.indexOf(Math.min(...diffs))];
            let bl = pts[diffs.indexOf(Math.max(...diffs))];

            let res = cv.matFromArray(4, 1, cv.CV_32S, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
            approx.delete();
            return res;
        }

        function renderOverlay(cnt) {
            ctxOutput.strokeStyle = "#10b981";
            ctxOutput.lineWidth = 15; // 視覺強化
            ctxOutput.lineJoin = "round";
            ctxOutput.beginPath();
            ctxOutput.moveTo(cnt.data32S[0], cnt.data32S[1]);
            for (let i = 1; i < 4; i++) { ctxOutput.lineTo(cnt.data32S[i*2], cnt.data32S[i*2+1]); }
            ctxOutput.closePath();
            ctxOutput.stroke();
            
            // 繪製角落大型提示點
            ctxOutput.fillStyle = "#10b981";
            for (let i = 0; i < 4; i++) {
                ctxOutput.beginPath();
                ctxOutput.arc(cnt.data32S[i*2], cnt.data32S[i*2+1], 18, 0, Math.PI*2);
                ctxOutput.fill();
            }
        }

        function validateStability(cnt) {
            let m = cv.moments(cnt);
            let cx = m.m10/m.m00, cy = m.m01/m.m00;
            if (!lastRect) { lastRect = {cx, cy}; return false; }
            let d = Math.hypot(cx - lastRect.cx, cy - lastRect.cy);
            lastRect = {cx, cy};
            return d < 6; // 嚴格的穩定度檢查
        }

        function captureCard(src, cnt) {
            scanActive = false;
            let p = [
                {x: cnt.data32S[0], y: cnt.data32S[1]}, {x: cnt.data32S[2], y: cnt.data32S[3]},
                {x: cnt.data32S[4], y: cnt.data32S[5]}, {x: cnt.data32S[6], y: cnt.data32S[7]}
            ];
            // 計算裁切尺寸
            let w = Math.max(Math.hypot(p[1].x-p[0].x, p[1].y-p[0].y), Math.hypot(p[2].x-p[3].x, p[2].y-p[3].y));
            let h = Math.max(Math.hypot(p[3].x-p[0].x, p[3].y-p[0].y), Math.hypot(p[2].x-p[1].x, p[2].y-p[1].y));
            
            let sTri = cv.matFromArray(4, 1, cv.CV_32FC2, [p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y]);
            let dTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, w, 0, w, h, 0, h]);
            let M = cv.getPerspectiveTransform(sTri, dTri);
            let result = new cv.Mat();
            cv.warpPerspective(src, result, M, new cv.Size(w, h));

            cv.imshow(canvasBuffer, result);
            document.getElementById('resultImg').src = canvasBuffer.toDataURL('image/png');
            document.getElementById('resultView').style.display = 'flex';
            sTri.delete(); dTri.delete(); M.delete(); result.delete();
        }

        function cleanup(mats) { mats.forEach(m => { if(m && !m.isDeleted()) m.delete(); }); }
        function restartScan() { document.getElementById('resultView').style.display='none'; scanActive=true; stableCount=0; lastRect=null; requestAnimationFrame(processLoop); }
        function downloadResult() { 
            const a = document.createElement('a'); 
            a.download=`Card_Scan_${Date.now()}.png`; 
            a.href=document.getElementById('resultImg').src; 
            a.click(); 
        }
        window.onload = init;
    </script>
</body>
</html>

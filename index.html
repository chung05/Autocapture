<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>智能名片掃描器-強效版</title>
    <script async src="https://docs.opencv.org/4.9.0/opencv.js"></script>
    <style>
        :root { --primary: #10b981; --bg: #0f172a; --text: #f8fafc; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .header { padding: 12px; text-align: center; background: rgba(30, 41, 59, 0.9); z-index: 10; border-bottom: 1px solid rgba(255,255,255,0.1); }
        h1 { margin: 0; font-size: 0.9rem; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; }
        .scanner-container { position: relative; flex: 1; background: #000; display: flex; justify-content: center; align-items: center; }
        #canvasOutput { width: 100%; height: 100%; object-fit: contain; }
        #video { display: none; }
        .overlay { position: absolute; bottom: 30px; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        .status-badge { background: rgba(0, 0, 0, 0.85); padding: 12px 24px; border-radius: 30px; font-size: 0.9rem; border: 2px solid rgba(255, 255, 255, 0.15); margin-bottom: 10px; transition: all 0.3s; }
        .status-badge.stable { border-color: var(--primary); color: var(--primary); box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); transform: scale(1.05); }
        .progress-bar { width: 200px; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; overflow: hidden; display: none; }
        #progressFill { height: 100%; width: 0%; background: var(--primary); transition: width 0.1s linear; }
        #loadingScreen { position: fixed; inset: 0; background: var(--bg); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        .spinner { width: 40px; height: 40px; border: 4px solid rgba(16,185,129,0.2); border-top: 4px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #resultView { position: fixed; inset: 0; background: var(--bg); z-index: 50; display: none; flex-direction: column; padding: 20px; }
        .result-card { background: #1e293b; padding: 8px; border-radius: 12px; margin-top: 10px; text-align: center; flex: 1; display: flex; align-items: center; justify-content: center; }
        #resultImg { max-width: 100%; max-height: 70vh; border-radius: 4px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .action-btns { display: flex; gap: 12px; margin-top: 20px; padding-bottom: 20px; }
        button { flex: 1; padding: 18px; border-radius: 14px; border: none; font-weight: bold; font-size: 1rem; cursor: pointer; }
        .btn-save { background: var(--primary); color: white; }
        .btn-retry { background: #475569; color: white; }
    </style>
</head>
<body>
    <div id="loadingScreen"><div class="spinner"></div><div>啟動影像引擎中...</div></div>
    <div class="header"><h1>智能名片掃描 (反光與圓角修復版)</h1></div>
    <div class="scanner-container">
        <video id="video" playsinline></video>
        <canvas id="canvasOutput"></canvas>
        <div class="overlay">
            <div id="statusBadge" class="status-badge">等待相機啟動...</div>
            <div id="progressContainer" class="progress-bar"><div id="progressFill"></div></div>
        </div>
    </div>
    <div id="resultView">
        <div class="result-card"><img id="resultImg" src=""></div>
        <div class="action-btns">
            <button class="btn-retry" onclick="restartScan()">重新拍攝</button>
            <button class="btn-save" onclick="downloadResult()">保存到相簿</button>
        </div>
    </div>
    <canvas id="canvasBuffer" style="display:none;"></canvas>

    <script>
        let video, canvasOutput, ctxOutput, canvasBuffer, statusBadge, progressFill, progressContainer;
        let streaming = false, stableCount = 0, lastRect = null, scanActive = true;
        const STABLE_REQ = 15; // 調低一點點要求以增加流暢度

        function init() {
            video = document.getElementById('video');
            canvasOutput = document.getElementById('canvasOutput');
            ctxOutput = canvasOutput.getContext('2d', { alpha: false });
            canvasBuffer = document.getElementById('canvasBuffer');
            statusBadge = document.getElementById('statusBadge');
            progressFill = document.getElementById('progressFill');
            progressContainer = document.getElementById('progressContainer');
            checkCV();
        }

        function checkCV() {
            if (typeof cv !== 'undefined' && cv.Mat) {
                document.getElementById('loadingScreen').style.display = 'none';
                startCamera();
            } else { setTimeout(checkCV, 200); }
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    streaming = true;
                    statusBadge.innerText = "將名片移入鏡頭...";
                    requestAnimationFrame(processLoop);
                };
            } catch (err) { 
                statusBadge.innerText = "相機啟動失敗";
                alert("無法存取相機，請確認已授予權限。"); 
            }
        }

        function processLoop() {
            if (!streaming || !scanActive) return;

            try {
                if (canvasOutput.width !== video.videoWidth) {
                    canvasOutput.width = video.videoWidth;
                    canvasOutput.height = video.videoHeight;
                }
                ctxOutput.drawImage(video, 0, 0, canvasOutput.width, canvasOutput.height);

                let src = cv.imread(canvasOutput);
                let gray = new cv.Mat(), binary = new cv.Mat(), morphed = new cv.Mat();
                
                // 1. 灰階處理
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // 2. 輕量化邊緣增強：先高斯模糊減少雜訊
                cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
                
                // 3. 使用較簡單的 Canny 配合 Dilate，降低 adaptiveThreshold 的運算負擔
                cv.Canny(gray, binary, 75, 200);
                let M_kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                cv.dilate(binary, morphed, M_kernel); // 膨脹線條以連結斷點

                let contours = new cv.MatVector(), hierarchy = new cv.Mat();
                cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let bestCard = null, maxArea = 0;
                const viewArea = src.rows * src.cols;

                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    
                    if (area > viewArea * 0.1 && area < viewArea * 0.95) {
                        let hull = new cv.Mat();
                        cv.convexHull(cnt, hull, false, true);
                        
                        let peri = cv.arcLength(hull, true);
                        let approx = new cv.Mat();
                        cv.approxPolyDP(hull, approx, 0.02 * peri, true);

                        // 判斷是否為合理的矩形區域 (4-8邊形)
                        if (approx.rows >= 4 && approx.rows <= 8) {
                            if (area > maxArea) {
                                maxArea = area;
                                if (bestCard) bestCard.delete();
                                bestCard = simplifyToFourPoints(approx);
                            } else { approx.delete(); }
                        } else { approx.delete(); }
                        hull.delete();
                    }
                }

                if (bestCard) {
                    renderOverlay(bestCard);
                    if (validateStability(bestCard)) {
                        stableCount++;
                        statusBadge.innerText = "鎖定成功，請保持不動...";
                        statusBadge.classList.add('stable');
                        progressContainer.style.display = 'block';
                        progressFill.style.width = (stableCount / STABLE_REQ * 100) + '%';
                        if (stableCount >= STABLE_REQ) {
                            captureCard(src, bestCard);
                            cleanup([src, gray, binary, morphed, contours, hierarchy, bestCard, M_kernel]);
                            return; // 拍照後終止迴圈
                        }
                    } else {
                        stableCount = 0;
                        statusBadge.innerText = "找到名片，穩定中...";
                        statusBadge.classList.remove('stable');
                    }
                } else {
                    stableCount = 0;
                    statusBadge.innerText = "尋找邊緣中 (請對準名片)";
                    progressContainer.style.display = 'none';
                }

                cleanup([src, gray, binary, morphed, contours, hierarchy, bestCard, M_kernel]);
            } catch (e) {
                console.error("Frame processing error:", e);
            }

            if (scanActive) requestAnimationFrame(processLoop);
        }

        function simplifyToFourPoints(approx) {
            let pts = [];
            for (let i = 0; i < approx.rows; i++) {
                pts.push({ x: approx.data32S[i*2], y: approx.data32S[i*2+1] });
            }
            let sums = pts.map(p => p.x + p.y);
            let diffs = pts.map(p => p.y - p.x);
            
            let tl = pts[sums.indexOf(Math.min(...sums))];
            let br = pts[sums.indexOf(Math.max(...sums))];
            let tr = pts[diffs.indexOf(Math.min(...diffs))];
            let bl = pts[diffs.indexOf(Math.max(...diffs))];

            let res = cv.matFromArray(4, 1, cv.CV_32S, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
            approx.delete();
            return res;
        }

        function renderOverlay(cnt) {
            ctxOutput.strokeStyle = "#10b981";
            ctxOutput.lineWidth = 12;
            ctxOutput.lineJoin = "round";
            ctxOutput.beginPath();
            ctxOutput.moveTo(cnt.data32S[0], cnt.data32S[1]);
            for (let i = 1; i < 4; i++) { ctxOutput.lineTo(cnt.data32S[i*2], cnt.data32S[i*2+1]); }
            ctxOutput.closePath();
            ctxOutput.stroke();
            
            ctxOutput.fillStyle = "#10b981";
            for (let i = 0; i < 4; i++) {
                ctxOutput.beginPath();
                ctxOutput.arc(cnt.data32S[i*2], cnt.data32S[i*2+1], 15, 0, Math.PI*2);
                ctxOutput.fill();
            }
        }

        function validateStability(cnt) {
            let m = cv.moments(cnt);
            if (m.m00 === 0) return false;
            let cx = m.m10/m.m00, cy = m.m01/m.m00;
            if (!lastRect) { lastRect = {cx, cy}; return false; }
            let d = Math.hypot(cx - lastRect.cx, cy - lastRect.cy);
            lastRect = {cx, cy};
            return d < 8; 
        }

        function captureCard(src, cnt) {
            scanActive = false;
            let p = [
                {x: cnt.data32S[0], y: cnt.data32S[1]}, {x: cnt.data32S[2], y: cnt.data32S[3]},
                {x: cnt.data32S[4], y: cnt.data32S[5]}, {x: cnt.data32S[6], y: cnt.data32S[7]}
            ];
            let w = Math.max(Math.hypot(p[1].x-p[0].x, p[1].y-p[0].y), Math.hypot(p[2].x-p[3].x, p[2].y-p[3].y));
            let h = Math.max(Math.hypot(p[3].x-p[0].x, p[3].y-p[0].y), Math.hypot(p[2].x-p[1].x, p[2].y-p[1].y));
            
            let sTri = cv.matFromArray(4, 1, cv.CV_32FC2, [p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y]);
            let dTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, w, 0, w, h, 0, h]);
            let M = cv.getPerspectiveTransform(sTri, dTri);
            let result = new cv.Mat();
            cv.warpPerspective(src, result, M, new cv.Size(w, h));

            cv.imshow(canvasBuffer, result);
            document.getElementById('resultImg').src = canvasBuffer.toDataURL('image/png');
            document.getElementById('resultView').style.display = 'flex';
            sTri.delete(); dTri.delete(); M.delete(); result.delete();
        }

        function cleanup(mats) { mats.forEach(m => { if(m && !m.isDeleted()) m.delete(); }); }
        
        function restartScan() { 
            document.getElementById('resultView').style.display='none'; 
            scanActive=true; 
            stableCount=0; 
            lastRect=null; 
            requestAnimationFrame(processLoop); 
        }

        function downloadResult() { 
            const a = document.createElement('a'); 
            a.download=`Card_Scan_${Date.now()}.png`; 
            a.href=document.getElementById('resultImg').src; 
            a.click(); 
        }
        window.onload = init;
    </script>
</body>
</html>
